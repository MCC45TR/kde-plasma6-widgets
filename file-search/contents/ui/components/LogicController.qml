import QtQuick
import org.kde.plasma.plasmoid
import org.kde.plasma.plasma5support as Plasma5Support
import "../js/HistoryManager.js" as HistoryManager
import "../js/PinnedManager.js" as PinnedManager
import "../js/CategoryManager.js" as CategoryManager
import "../js/TelemetryManager.js" as TelemetryManager
import "../js/ConfigManager.js" as ConfigManager
import "../js/utils.js" as Utils

Item {
    id: logicRoot
    
    // Required dependencies
    required property var plasmoidConfig
    required property var trFunc
    
    // Signals
    // Signals
    signal historyForceUpdate()
    // pinnedItemsChanged is automatically generated by property definition

    
    // ===== CONFIGURATION MANAGEMENT =====
    readonly property int userProfile: plasmoidConfig.userProfile || 0
    readonly property var profileDefaults: ConfigManager.getProfileDefaults(userProfile)
    readonly property int maxHistoryItems: ConfigManager.getMaxHistoryItems(userProfile)
    
    // Feature flags based on profile
    readonly property bool debugEnabled: ConfigManager.isFeatureEnabled(userProfile, "debug")
    readonly property bool previewEnabled: ConfigManager.isFeatureEnabled(userProfile, "preview")
    readonly property bool advancedSearchEnabled: ConfigManager.isFeatureEnabled(userProfile, "advancedSearch")
    readonly property bool telemetryEnabled: ConfigManager.isFeatureEnabled(userProfile, "telemetry")
    readonly property bool categoryPriorityEnabled: ConfigManager.isFeatureEnabled(userProfile, "categoryPriority")
    readonly property bool activityPinningEnabled: ConfigManager.isFeatureEnabled(userProfile, "activityPinning")
    
    // Config validation
    function validateConfig() {
        return ConfigManager.sanitizeConfig({
            displayMode: plasmoidConfig.displayMode,
            viewMode: plasmoidConfig.viewMode,
            iconSize: plasmoidConfig.iconSize,
            listIconSize: plasmoidConfig.listIconSize,
            previewEnabled: plasmoidConfig.previewEnabled,
            debugOverlay: plasmoidConfig.debugOverlay,
            userProfile: plasmoidConfig.userProfile
        })
    }
    
    function getRecommendedIconSize() {
        return ConfigManager.getRecommendedIconSize(
            plasmoidConfig.displayMode,
            plasmoidConfig.viewMode
        )
    }
    
    // ===== HISTORY MANAGEMENT =====
    property var searchHistory: []
    
    // ===== PINNED ITEMS MANAGEMENT =====
    property var pinnedItems: []
    property string currentActivityId: "global"
    
    // ===== CATEGORY SETTINGS =====
    property var categorySettings: {}
    
    // ===== TELEMETRY =====
    property var telemetryStats: TelemetryManager.getStatsObject(plasmoidConfig.telemetryData || "{}")
    
    // ===== HISTORY FUNCTIONS =====
    function loadHistory() {
        // Debug: console.log("FileSearch [History]: Loading history...")
        searchHistory = HistoryManager.loadHistory(plasmoidConfig.searchHistory)
    }
    
    function saveHistory() {
        plasmoidConfig.searchHistory = JSON.stringify(searchHistory)
    }
    
    function addToHistory(display, decoration, category, matchId, filePath, sourceType, queryText) {
        searchHistory = HistoryManager.addToHistory(searchHistory, display, decoration, category, matchId, filePath, sourceType, queryText, plasmoidConfig.maxHistoryItems)
        saveHistory()
        
        // Schedule delayed icon check (1s)
        if (searchHistory.length > 0) {
            iconCheckTimer.uuid = searchHistory[0].uuid
            iconCheckTimer.filePath = filePath
            iconCheckTimer.decoration = decoration
            iconCheckTimer.category = category
            iconCheckTimer.restart()
        }
    }
    
    function formatHistoryTime(timestamp) {
        return Utils.formatHistoryTime(timestamp, trFunc)
    }
    
    function clearHistory() {
        searchHistory = HistoryManager.clearHistory()
        saveHistory()
    }

    function removeFromHistory(uuid) {
        searchHistory = HistoryManager.removeFromHistory(searchHistory, uuid)
        saveHistory()
    }
    
    function executeCommand(command) {
        // Use the debug overlay's datasource pattern or similar mechanism if available
        // Since we don't have a global DataSource, we need to expose one here or usage site.
        // But for "Open With", "Trash", "Open Location", we need shell commands.
        // We will assume the view creates a DataSource for this purpose.
        // Or we can add one here.
    }
    
    // Global DataSource for shell commands
    Plasma5Support.DataSource {
        id: globalShellSource
        engine: "executable"
        connectedSources: []
        onNewData: (source, data) => {
            disconnectSource(source)
        }
    }
    
    function runShellCommand(cmd) {
        globalShellSource.connectedSources = [cmd]
    }
    
    // ===== ICON CHECK TIMER =====
    Timer {
        id: iconCheckTimer
        interval: 1000
        repeat: false
        property string uuid
        property string filePath
        property string decoration
        property string category
        
        onTriggered: {
            if (!uuid) return
            
            /// Only check if it has a file path
            if (filePath && filePath.toString().indexOf("file://") === 0) {
                // If decoration is broken (QIcon()) or missing
                if (decoration === "QIcon()" || decoration === "") {
                    // Set default folder icon temporarily if it's likely a folder
                    var isFolder = (category === "Yerler" || category === "Places" || category === "Klas√∂rler");
                    
                    if (isFolder) {
                        HistoryManager.updateItemIcon(searchHistory, uuid, "folder");
                        saveHistory();
                        historyForceUpdate();
                    }
                    
                    // Try to fetch custom icon from .directory file
                    fetchDirectoryIcon(filePath, uuid);
                }
            }
        }
    }

    function fetchDirectoryIcon(folderPath, uuid) {
         if (!folderPath || folderPath.toString().indexOf("file://") !== 0) return;
         
         var request = new XMLHttpRequest();
         // Add .directory to path. Ensure no double slash if path ends with /
         var path = folderPath.toString();
         if (path.slice(-1) === "/") path = path.slice(0, -1);
         var url = path + "/.directory";
         
         request.open("GET", url);
         request.onreadystatechange = function() {
             if (request.readyState === XMLHttpRequest.DONE) {
                 if (request.status === 200 || request.status === 0) {
                     var content = request.responseText;
                     // Look for Icon=...
                     var lines = content.split('\n');
                     for (var i = 0; i < lines.length; i++) {
                         var line = lines[i].trim();
                         if (line.indexOf("Icon=") === 0) {
                             var iconName = line.substring(5).trim();
                             if (iconName.length > 0) {
                                 // Debug: console.log("FileSearch [Icon]: Found custom icon:", iconName);
                                 if (HistoryManager.updateItemIcon(logicRoot.searchHistory, uuid, iconName)) {
                                     logicRoot.saveHistory();
                                     logicRoot.historyForceUpdate();
                                 }
                                 return;
                             }
                         }
                     }
                 }
             }
         };
         request.send();
    }
    
    // ===== PINNED FUNCTIONS =====
    function loadPinned() {
        // Debug: console.log("FileSearch [Pinned]: Loading pinned items...")
        pinnedItems = PinnedManager.loadPinned(plasmoidConfig.pinnedItems)
    }
    
    function savePinned() {
        plasmoidConfig.pinnedItems = PinnedManager.savePinned(pinnedItems)
    }
    
    function pinItem(item) {
        pinnedItems = PinnedManager.pinItem(pinnedItems, item, currentActivityId)
        savePinned()
        pinnedItemsChanged()
    }
    
    function unpinItem(matchId) {
        pinnedItems = PinnedManager.unpinItem(pinnedItems, matchId, currentActivityId)
        savePinned()
        pinnedItemsChanged()
    }
    
    function isPinned(matchId) {
        return PinnedManager.isPinned(pinnedItems, matchId, currentActivityId)
    }
    
    function togglePin(item) {
        pinnedItems = PinnedManager.togglePin(pinnedItems, item, currentActivityId)
        savePinned()
        pinnedItemsChanged()
    }
    
    function getVisiblePinnedItems() {
        return PinnedManager.getPinnedForActivity(pinnedItems, currentActivityId)
    }
    
    function getPinInfo(matchId) {
        return PinnedManager.getPinInfo(pinnedItems, matchId, currentActivityId)
    }
    
    // Activity management
    readonly property string currentActivityName: currentActivityId === "global" ? "Global" : currentActivityId
    
    function setActivity(activityId) {
        currentActivityId = activityId || "global"
    }
    
    function pinItemToActivity(item, activityId) {
        pinnedItems = PinnedManager.pinItem(pinnedItems, item, activityId || "global")
        savePinned()
        pinnedItemsChanged()
    }
    
    // ===== CATEGORY SETTINGS FUNCTIONS =====
    function loadCategorySettings() {
        // Debug: console.log("FileSearch [Category]: Loading category settings...")
        categorySettings = CategoryManager.loadCategorySettings(plasmoidConfig.categorySettings)
    }
    
    function processCategories(categories) {
        return CategoryManager.processCategories(categories, categorySettings)
    }
    
    function isCategoryVisible(categoryName) {
        return CategoryManager.isCategoryVisible(categorySettings, categoryName)
    }
    
    function getEffectiveIcon(categoryName, defaultIcon) {
        return CategoryManager.getEffectiveIcon(categorySettings, categoryName, defaultIcon)
    }
    
    function updateTelemetry(latency) {
        var newData = TelemetryManager.recordSearch(plasmoidConfig.telemetryData || "{}", latency)
        plasmoidConfig.telemetryData = newData
        telemetryStats = TelemetryManager.getStatsObject(newData)
    }

    // ===== DEPENDENCY CHECKS =====
    property bool manInstalled: true
    
    Plasma5Support.DataSource {
        id: manCheckSource
        engine: "executable"
        connectedSources: []
        onNewData: (source, data) => {
            if (data["exit code"] !== undefined) {
                logicRoot.manInstalled = (data["exit code"] === 0)
                disconnectSource(source)
            }
        }
    }

    function checkManAvailability() {
         manCheckSource.connectedSources = ["command -v man"]
    }

    // ===== INITIALIZATION =====
    Component.onCompleted: {
        loadHistory()
        loadPinned()
        loadCategorySettings()
        checkManAvailability()
    }
}
